# LoadPenaltyMatrix(MatrixID): Loads and initializes penalty matrix for scoring matches and mismatches
# input: MatrixID (May need to update file path in function to load within proper directory)
# output: PenaltyMatrix, AA_Num

# LCSBackTrack_GapPenalty(v, w, match, mismatch, indel, ExtGapPen): creates memoize and backtrack matrices. Creates top, middle and bottom memoize matrices for scoring gap penalities
# input: amino acid strings v and w, score of match and mismatch (If using penalty matrix, set match and mismath to 'matrix', indel score, and extended gap penalty score
# output: backtrack matrix

# OutputLCS_Top(backtrack, v, i, j): Provides top string of the final alignment

# OutputLCS_Bottom(backtrack, v, i, j): Provides bottomw string of the final alignment

# LCSwExtGapPenalties(v, w, match, mismatch, indel, ExtGapPen): combines LCSBackTrack_GapPenalty, OutputLCS_Top and OutputLCS_Bottom functions to generate final alignment
#input: amino acid strings v and w, score of match and mismatch (If using penalty matrix, set match and mismath to 'matrix', indel score, and extended gap penalty score
# Output: Sequence alignments

import numpy as np
import sys
import math
import math
sys.setrecursionlimit(10000)

def LoadPenaltyMatrix(MatrixID):
    Location = 'C:\\Users\\sjhar\\OneDrive\\Documents\\Educational\\Coursera\\BIOI 3\\Wk 2 Penalized Alignments\\{}.txt'.format(str(MatrixID))
    Matrix = list(open(Location, 'r'))
    Matrix = [x.split() for x in Matrix]
    PenaltyMatrix, AA_Num = [], {}
    for row in Matrix[1:]:
        PenaltyMatrix.append(list(map(int, row[1:])))
    PenaltyMatrix = np.matrix(PenaltyMatrix)
    # print(PenaltyMatrix)
    for AA in range(len(Matrix[0])):
        AA_Num[Matrix[0][AA]] = AA
    return PenaltyMatrix, AA_Num

def DiscoverAdjCol(v, wLetter, match, mismatch, indel, memoryColumn, PenaltyMatrix, AA_Num):
    # print( match, mismatch, indel)
    #Intitalize
    discoveryColumn = [memoryColumn[0] - indel]

    ## Make the algo run just once!!!
    for i in range(1,len(v)+1):
        if match == 'matrix':
            MidScore = PenaltyMatrix.item(AA_Num[v[i - 1]], AA_Num[wLetter])
        else:
            if v[i-1] == wLetter:
                MidScore = match
            else:
                MidScore = -mismatch
                # except TypeError:
                #     print(v, wLetter, match, mismatch, indel, memoryColumn)
        # print("Midscore =", MidScore)

        #Make Comparison:
        discoveryColumn.append(max(discoveryColumn[i-1] - indel, memoryColumn[i] - indel, memoryColumn[i-1] + MidScore))
        # print('memory:   ',memoryColumn)
        # print('discovery:',discoveryColumn)

    return discoveryColumn

# print(DiscoverAdjCol("EA", "E", 'match', 'match', 5, [0, -5, -10]))

def MiddleEdge(v, w, match, mismatch, indel, top ='NA', bottom ='NA', left ='NA', right ='NA'):
    TrueTop, TrueBottom, TrueLeft, TrueRight = top, bottom, left, right
    ## Initialize if needed
    if top == 'NA':
        top = 0
        TrueTop = 0
    if bottom == 'NA':
        bottom = len(v)
        TrueBottom = len(v)
    if left == 'NA':
        left = 0
        TrueLeft = 0
    if right == 'NA':
        right = len(w)
        TrueRight = len(w)
    middleNodeLeft = (right - left) // 2
    middleNodeRight = math.ceil((right - left) / 2)
    v = v[top:bottom]
    w = w[left:right]
    top, bottom, left, right = 0, len(v), 0, len(w)
    # print(top, bottom, left, right)
    # print('v = {}, w = {}, top = {}, bottom = {}, left = {}, right = {}'.format(v, w, top, bottom, left, right))
    # print(middleNodeLeft, middleNodeRight)

    ## Initialize variables
    VL, WL = len(v), len(w)
    MiddleNodes, MiddleScores = [], []
    ## Conversion lists for mapping right hand graph
    VConversionList = list(reversed(range(bottom+1)))

    ## Load the penalty matrix
    LoadMatrix = LoadPenaltyMatrix('BLOSUM62')
    PenaltyMatrix, AA_Num = LoadMatrix[0], LoadMatrix[1]

    ##~~~~~~~~~~~~~~~~~~~~~~~Find middle node~~~~~~~~~~~~~~~~~~~~~~~
    ## Initialize memory column for the discovery column
    memoryColumn = []
    for i in range(top, bottom + 1):
        memoryColumn.append(-(indel * (i)))
    # print("BEGIN FWD MEMORY TROUBLESHOOT")
    # print('1st memory col:', memoryColumn, 'middleNodeLeft:',middleNodeLeft)

    ## Finds each column with linear memory from left to right of upper left rectangle
    for i in range(middleNodeLeft):
        # print(v[top:bottom], w[i], match, mismatch, indel, memoryColumn)
        memoryColumn = DiscoverAdjCol(v[top:bottom], w[i], match, mismatch, indel, memoryColumn, PenaltyMatrix, AA_Num)
    # print("Fwd memory:", memoryColumn)
    FwdMemory1 = memoryColumn
    # print('last adjacent col', FwdMemory1)

    # if left == 0:
    memoryColumn = []
    for i in range(top, bottom + 1):
        memoryColumn.append(-(indel * (i)))
    # print('memory column for reverse:',memoryColumn)

    vReverse, wReverse = v[::-1], w[::-1]
    # print(w)
    # print(list(range(right-1, middleNodeLeft-1,-1)))
    # print(memoryColumn[::-1])
    # print('Right =', right, "middlienodeleft =", middleNodeLeft)
    for i in range(right - left - 1, middleNodeLeft - 1, -1):
        memoryColumn = DiscoverAdjCol(vReverse, w[i], match, mismatch, indel, memoryColumn, PenaltyMatrix, AA_Num)
        # print(memoryColumn)
    # print("Bkd memory:", memoryColumn[::-1])
    BkdMemory = memoryColumn

    ## Calculate the longest path
    TotalLengthDict, TotalLength = {}, []
    # print('Fwd', FwdMemory1, 'bkd', BkdMemory)
    for i in range(bottom-top+1):
        Total = FwdMemory1[i] + BkdMemory[VConversionList[i]]
        TotalLength.append(Total)
        if Total not in TotalLengthDict:
            TotalLengthDict[Total] = i
        else:
            if i < TotalLengthDict[Total]:
                TotalLengthDict[Total] = i

    MiddleV = TotalLengthDict[max(TotalLength)]
    MiddleNode = (MiddleV, middleNodeLeft)
    # print(MiddleNode)
    if len(v) > 1:
        DownWeight = TotalLength[MiddleV+1]
    else:
        DownWeight = -math.inf
    # print(TotalLength, MiddleNode, DownWeight)

    # Find Adj middle node:
    if left == 0:
        memoryColumn = []
        for i in range(top, bottom + 1):
            memoryColumn.append(-(indel * (i)))

    # print(w)
    # print(list(range(left, middleNodeLeft+1)))
    # print(memoryColumn)
    for i in range(left, middleNodeLeft + 1):
        memoryColumn = DiscoverAdjCol(v[top:bottom], w[i], match, mismatch, indel, memoryColumn, PenaltyMatrix, AA_Num)
        # print(memoryColumn)
    # print("Fwd memory:", memoryColumn)
    FwdMemory2 = memoryColumn

    if left == 0:
        memoryColumn = []
        for i in range(top, bottom + 1):
            memoryColumn.append(-(indel * (i)))

    vReverse, wReverse = v[::-1], w[::-1]
    # print(w)
    # print(list(range(right-1, middleNodeLeft,-1)))
    # print(memoryColumn[::-1])
    for i in range(right -left - 1, middleNodeLeft, -1):
        memoryColumn = DiscoverAdjCol(v[top:bottom][::-1], w[i], match, mismatch, indel, memoryColumn, PenaltyMatrix, AA_Num)
        # print(memoryColumn[::-1])
    # print("Bkd memory:", memoryColumn[::-1])
    BkdMemory = memoryColumn

    TotalLengthDict, TotalLength = {}, []

    if MiddleNode[0] == bottom:
        AdjVerticalSearch = MiddleNode[0] + 1
    else:
        AdjVerticalSearch = MiddleNode[0] + 2
    # print(list(range(MiddleNode[0],AdjVerticalSearch)))
    for i in range(MiddleNode[0],AdjVerticalSearch):
        Total = FwdMemory2[i] + BkdMemory[VConversionList[i]]
        # print(FwdMemory2[i], "+",BkdMemory[VConversionList[i]],"=", Total)
        if Total not in TotalLengthDict:
            TotalLengthDict[Total] = i
            TotalLength.append(Total)
        else:
            if i < TotalLengthDict[Total]:
                TotalLengthDict[Total] = i
                TotalLength.append(Total)
    # print(TotalLength)
    if len(TotalLength) > 1:
        if TotalLength[0] > TotalLength[1]:
            AdjMiddleNode = (MiddleNode[0], middleNodeLeft+1)
            print("Horizontal")
        else:
            print("Diagonal")
            AdjMiddleNode = (MiddleNode[0]+1, middleNodeLeft + 1)
    else:
        print('Total Length singular')
        AdjMiddleNode = (MiddleNode[0], middleNodeLeft + 1)
    # print(DownWeight, TotalLength)
    if DownWeight > max(TotalLength):
        print("Vertical")
        AdjMiddleNode = (MiddleNode[0] + 1, middleNodeLeft)
    # print(AdjMiddleNode)
    # print(MiddleNode[0], MiddleNode[1], AdjMiddleNode[0], AdjMiddleNode[1], type(MiddleNode[0]), type(MiddleNode[1]), type(AdjMiddleNode[0]), type(AdjMiddleNode[1]))
    MiddleNode = (MiddleNode[0] + TrueTop, MiddleNode[1] + TrueLeft)
    AdjMiddleNode = (AdjMiddleNode[0] + TrueTop, AdjMiddleNode[1] + TrueLeft)
    return MiddleNode, AdjMiddleNode

# print(MiddleEdge('PLEASANTLY', 'MEASNLY', 'matrix', 'matrix', 5))
# print(MiddleEdge('CC', 'TTTT', 1, 5, 1))
# # (0, 2) (0, 3)
# print(MiddleEdge('AT', 'GAT', 1, 1, 2))
# # (0, 1) (1, 2)
# print(MiddleEdge('TTCTT', 'TTTT', 1, 1, 1))
# # (2, 2) (3, 2)
# print(MiddleEdge('G', 'GAACCC', 1, 5, 1))
# # (1, 3) (1, 4)
# print(MiddleEdge('CAT', 'ACAGT', 2, 3, 1))
# # (1, 2) (2, 3)
# print(MiddleEdge('AATCCC', 'T', 2, 5, 3))
# (0, 0) (1, 0)
# print(MiddleEdge('ACDEACDE', 'ACDEACDE', 2, 5, 3))
# print(MiddleEdge('ACDEACDE', 'ACDEACDE', 2, 5, 3, 0, 2, 0, 2))

def LinearSpaceAlignment(v, w, match, mismatch, indel, top = 'NA', bottom = 'NA', left = 'NA', right = 'NA'):
    # print(v, w)
    ## Initialize if needed
    if top == 'NA':
        top = 0
    if bottom == 'NA':
        bottom = len(v)
    if left == 'NA':
        left = 0
    if right == 'NA':
        right = len(w)

    if left == right:
        print('LEFT = RIGHT')
        return "Vertical Moves"
    if top == bottom:
        print("TOP = BOTTOM")
        return "Horizontal Moves"
    # print(top, bottom, left, right)

    middle = (left + right)//2
    midEdge = MiddleEdge(v, w, match, mismatch, indel, top, bottom, left, right)
    midNode = midEdge[0][0]

    ## Find middle edge of top left rectangle
    # print(top, midNode, left, middle)
    LinearSpaceAlignment(v, w, match, mismatch, indel, top, midNode, left, middle)
    print('midEdge: ', midEdge, top, bottom, left, right)

    ## Find dimensions of lower right rectangle based on middle edge direction
    # print(midEdge)
    midEdgeDirection = None
    if midEdge[1][1] - midEdge[0][1] == 1:
        middle += 1
        midEdgeDirection = 'H'
    if midEdge[1][0] - midEdge[0][0] == 1:
        midNode += 1
        if midEdgeDirection == 'H':
            midEdgeDirection = 'D'
        else:
            midEdgeDirection = 'V'
    # return midEdgeDirection
    print('midEdgeDirection:', midEdgeDirection, 'From:', midEdge)
    LinearSpaceAlignment(v, w, match, mismatch, indel, midNode, bottom, middle, right)


# print(MiddleEdge('PLEASANTLY', 'MEASNLY', 'matrix','matrix',5, 3, 4, 2, 3))
# print(MiddleEdge('PLEASANTLY', 'MEASNLY', 'matrix','matrix',5,))
print(LinearSpaceAlignment('PLEASANTLY', 'MEASNLY', 'matrix','matrix',5))

Location = 'C:\\Users\\sjhar\\OneDrive\\Documents\\Educational\\Coursera\\BIOI 3\\Wk 2 LinearSpaceAlignment\\dataset_250_14 (1).txt'
Matrix = list(open(Location, 'r'))
Matrix = [x.strip() for x in Matrix]
# print(Matrix)
# print(MiddleEdge(Matrix[0], Matrix[1], 'matrix', 'matrix', 5))


#Recursive Test

def PathwayTest(Sequence):
    if len(Sequence) < 1:
        return Sequence
    return PathwayTest(Sequence[:-1]) + Sequence[-1]

# print(PathwayTest('apple'))



# import random
# def test(input_string):
#     l = len(input_string)
#     if l >= 10:
#         return input_string
#     input_string += random.choice('abcdefghijklmnopqrstuvwxyz'
#                                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ')
#     return test(input_string)

# print(test(''))
